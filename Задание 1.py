# python3.9
# функция определения чётности из задания
def isEven(value):
    return value % 2 == 0

# тестовые примеры
print(isEven(5))
print(isEven(10))
print(isEven(1011))
print()

# инвертированная функция определения чётности, тоже что и isEven, но работает наоборот,
# выдавая одинаковый результат
def isEvenInvert(value):
    return value % 2 != 1

#тестовые примеры
print(isEvenInvert(5))
print(isEvenInvert(10))
print(isEvenInvert(1011))

# Первая реализация на вход получает целое число, берёт остаток от деления этого числа на 2 и сравнивает с 0.
# Если условие верно (проверка на равенство), то результатом будет True- число чётное. Если не верно, то False- число не чётное.

# Вторая реализация на вход получает целое число, берёт остаток от деления этого числа на 2 и сравнивает его уже с 1.
# Если условие верно (тут проверка на неравенство) результат будет True- число чётное. Если не верно, то False- число не чётное.
# Таким образом сделав 2 исправления поменял логику на обратную в 2 местах, что дало в итоге одинаковый результат с оригинальной функцией.

# ВЫВОД: 1 реализация имеет прямую логику, понятную сходу, в то время как
#        2 реализация имеет логику обратную, что воспринимается и читается в коде посложнее.